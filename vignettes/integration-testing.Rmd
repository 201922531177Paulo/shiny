---
title: "Integration Testing in Shiny"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Your Vignette Title}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction to Inspecting Modules

First, we'll define a simple Shiny module:

```{r}
library(shiny)
module <- function(input, output, session) {
  rv <- reactiveValues(x = 0)
  observe({
    rv$x <- input$x * 2
  })
  output$txt <- renderText({
    paste0("Value: ", rv$x)
  })
}
```

This module

  - depends on one input (`x`),
  - has an intermediate, internal `reactiveValues` (`rv`) which updates reactively,
  - and updates an output (`txt`) reactively. 
  
It would be nice to write tests that confirm that the module behaves the way we expect. We can do so using the `testModule` function.

```{r}
testModule(module, {
  cat("Initially, input$x is NULL, right?", is.null(input$x), "\n")
  
  # Give input$x a value.
  session$setInputs(x = 1)
  
  cat("Now that x is set to 1, rv$x is: ", rv$x, "\n")
  cat("\tand output$txt is: ", output$txt, "\n")

  # Now update input$x to a new value
  session$setInputs(x = 2)
  
  cat("After updating x to 2, rv$x is: ", rv$x, "\n")
  cat("\tand output$txt is: ", output$txt, "\n")
})
```

There are a few things to notice in this example. 

First, the test expression provided here assumes the existence of some variables -- specifically, `input`, `output`, and `r`. This is safe because the test code provided to `testModule` is run in the module's environment. This means that any parameters passed in to your module (such as `input`, `output`, and `session`) are readily available, as are any intermediate objects or reactives that you define in the module (such as `r`).

Second, you'll need to give values to any inputs that you want to be defined; by default, they're all `NULL`. We do that using the `session$setInputs()` method. The `session` object used in `testModule` differs from the real `session` object Shiny uses; this allows us to tailor it to be more suitable for testing purposes by modifying or creating new methods such as `setInputs()`.

Last, you're likely used to assigning to `output`, but here we're reading from `output$txt` in order to check its value. When running inside `testModule`, you can simply reference an output and it will give the value produced by the `render` function.

## Automated Tests

Realistically, we don't want to just print the values for manual inspection; we'll want to leverage them in automated tests. That way, we'll be able to build up a collection of tests that we can run against our module in the future to confirm that it always behaves correctly. You can use whatever testing framework you'd like (or none a all!), but we'll use the `expect_*` functions from the testthat package in this example.

```{r}
# Bring in testthat just for its expectations
suppressWarnings(library(testthat))

testModule(module, {
  session$setInputs(x = 1)
  expect_equal(rv$x, 2)
  expect_equal(output$txt, "Value: 2")

  session$setInputs(x = 2)
  expect_equal(rv$x, 4)
  expect_equal(output$txt, "Value: 4")
})
```

If there's no error, then we know our tests ran successfully. If there were a bug, we'd see an error printed. For example:

```{r}
tryCatch({
  testModule(module, {
    session$setInputs(x = 1)
    
    # This expectation will fail
    expect_equal(rv$x, 99)
  })
}, error=function(e){
  print("There was an error!")
  print(e)
})
```

## Promises

`testModule` can handle promises inside of render functions.

```{r}
library(promises)
library(future)
plan(multisession)

module <- function(input, output, session){
  output$async <- renderText({
    # Stash the value since you can't do reactivity inside of a promise. See 
    # https://rstudio.github.io/promises/articles/shiny.html#shiny-specific-caveats-and-limitations
    t <- input$times
    
    # A promise chain that repeats the letter A and then collapses it into a string.
    future({ rep("A", times=t) }) %...>%
      paste(collapse="")
  })
}

testModule(module, {
  session$setInputs(times = 3)
  expect_equal(output$async, "AAA")
  
  session$setInputs(times = 5)
  expect_equal(output$async, "AAAAA")
})
```

As you can see, no special precautions were required for a `render` function that uses promises. Behind-the-scenes, the code in `testModule` will block when trying to read from an `output` that returned a promise. This allows you to interact with the outputs in your tests as if they were synchronous.

TODO: What about internal reactives that are promise-based? We don't do anything special for them...

## Modules with additional inputs

`testModule` can also handle modules that accept additional arguments such as this one.

```{r}
module <- function(input, output, session, arg1, arg2){
  output$txt1 <- renderText({ arg1 })
  
  output$txt2 <- renderText({ arg2 })
}
```

Additional arguments should be passed after the test expression as named parameters.

```{r}
testModule(module, {
  expect_equal(output$txt1, "val1")
  expect_equal(output$txt2, "val2")
}, arg1="val1", arg2="val2")
```

## Accessing a module's returned value

Some modules return reactive data as an output. For such modules, it can be helpful to test the returned value, as well. The returned value from the module is made available as a property on the mock `session` object as demonstrated in this example.

```{r}
module <- function(input, output, session){
    reactive({
      return(input$a + input$b)
    })
  }

  testModule(module, {
    session$setInputs(a = 1, b = 2)
    expect_equal(session$returned(), 3)

    # And retains reactivity
    session$setInputs(a = 2)
    expect_equal(session$returned(), 4)
  })
```

## Timer and Polling

Testing behavior that relies on timing is notoriously difficult. Modules will behave differently on different machines and under different conditions. In order to make testing with time more deterministic, `testModule` uses simulated time that you control, rather than the actual computer time. Let's look at what happens when you try to use "real" time in your testing.

```{r}
module <- function(input, output, session){
  rv <- reactiveValues(x=0)
  
  observe({
    invalidateLater(100)
    isolate(rv$x <- rv$x + 1)
  })
}

testModule(module, {
  expect_equal(rv$x, 1) # The observer runs once at initialization
  
  Sys.sleep(1) # Sleep for a second
  
  expect_equal(rv$x, 1) # The value hasn't changed
})
```

This behavior may be surprising. It seems like rv$x should have been incremented 10 times (or perhaps 9, due to computational overhead). But in truth, it hasn't changed at all. This is because `testModule` doesn't consider the actual time on your computer -- only its simulated understanding of time.

In order to cause `testModule` to progress through time, instead of `Sys.sleep`, we'll use `session$elapse` -- another method that exists only on our mocked session object. Using the same module object as above...

```{r}
testModule(module, {
  expect_equal(rv$x, 1) # The observer runs once at initialization
  
  session$elapse(100) # Elapse 100ms -- just long enough to trigger a reactive invalidation
  
  expect_equal(rv$x, 2) # The observer was invalidated and the value updated!
  
  # You can even simulate multiple events in a single elapse
  session$elapse(300)
  expect_equal(rv$x, 5)
})
```

As you can see, using `session$elapse` caused `testModule` to recognize that (simulted) time had passed which triggered the reactivity as we'd expect. This approach allows you to deterministically control time in your tests while avoiding expensive pauses that would slow down your tests. Using this approach, this test can complete in only a fraction of the 100ms that it simulates.

## Complex Outputs (plots, htmlwidgets)

TODO

## Testing Servers

TODO: Will show that you can pass in a shinyapp object or a server function to a similar function called `testServer` and it will work similarly.
